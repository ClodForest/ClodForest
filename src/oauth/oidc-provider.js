// Generated by CoffeeScript 2.7.0
(function() {
  // FILENAME: { ClodForest/src/oauth/oidc-provider.coffee }
  // OIDC Provider configuration for OAuth2 server
  var DATA_DIR, FileAdapter, Provider, configuration, createProvider, fs, logger, path;

  Provider = require('oidc-provider').Provider;

  path = require('node:path');

  fs = require('node:fs/promises');

  ({logger} = require('../lib/logger'));

  // Data directory for persistence
  DATA_DIR = path.join(process.cwd(), 'data', 'oauth2');

  // File-based adapter for oidc-provider
  FileAdapter = class FileAdapter {
    constructor(name1) {
      this.name = name1;
      this.dataFile = path.join(DATA_DIR, `${this.name}.json`);
      this.init();
    }

    async init() {
      var error;
      try {
        await fs.mkdir(DATA_DIR, {
          recursive: true
        });
        try {
          return (await fs.access(this.dataFile));
        } catch (error1) {
          return (await fs.writeFile(this.dataFile, JSON.stringify({}, null, 2)));
        }
      } catch (error1) {
        error = error1;
        return logger.error(`Failed to initialize ${this.name} storage`, {
          error: error.message
        });
      }
    }

    async loadData() {
      var data;
      try {
        data = (await fs.readFile(this.dataFile, 'utf8'));
        return JSON.parse(data);
      } catch (error1) {
        return {};
      }
    }

    async saveData(data) {
      return (await fs.writeFile(this.dataFile, JSON.stringify(data, null, 2)));
    }

    async upsert(id, payload, expiresIn) {
      var data, expiresAt;
      data = (await this.loadData());
      
      // Calculate expiration if provided
      expiresAt = expiresIn ? new Date(Date.now() + expiresIn * 1000) : null;
      data[id] = {
        payload: payload,
        expiresAt: expiresAt != null ? expiresAt.toISOString() : void 0,
        createdAt: new Date().toISOString()
      };
      await this.saveData(data);
      return void 0;
    }

    async find(id) {
      var data, record;
      data = (await this.loadData());
      record = data[id];
      if (!record) {
        return void 0;
      }
      
      // Check if expired
      if (record.expiresAt && new Date() > new Date(record.expiresAt)) {
        delete data[id];
        await this.saveData(data);
        return void 0;
      }
      return record.payload;
    }

    async findByUserCode(userCode) {
      var data, id, record, ref;
      data = (await this.loadData());
      for (id in data) {
        record = data[id];
        if (((ref = record.payload) != null ? ref.userCode : void 0) === userCode) {
          return this.find(id);
        }
      }
      return void 0;
    }

    async findByUid(uid) {
      var data, id, record, ref;
      data = (await this.loadData());
      for (id in data) {
        record = data[id];
        if (((ref = record.payload) != null ? ref.uid : void 0) === uid) {
          return this.find(id);
        }
      }
      return void 0;
    }

    async consume(id) {
      var data, record;
      data = (await this.loadData());
      record = data[id];
      if (!record) {
        return void 0;
      }
      record.payload.consumed = Math.floor(Date.now() / 1000);
      await this.saveData(data);
      return void 0;
    }

    async destroy(id) {
      var data;
      data = (await this.loadData());
      delete data[id];
      await this.saveData(data);
      return void 0;
    }

    async revokeByGrantId(grantId) {
      var data, i, id, len, record, ref, toDelete;
      data = (await this.loadData());
      toDelete = [];
      for (id in data) {
        record = data[id];
        if (((ref = record.payload) != null ? ref.grantId : void 0) === grantId) {
          toDelete.push(id);
        }
      }
      for (i = 0, len = toDelete.length; i < len; i++) {
        id = toDelete[i];
        delete data[id];
      }
      if (toDelete.length > 0) {
        await this.saveData(data);
      }
      return void 0;
    }

  };

  // OIDC Provider configuration
  configuration = {
    // OAuth2-only mode (disable OpenID Connect features we don't need)
    features: {
      devInteractions: {
        enabled: false
      },
      clientCredentials: {
        enabled: true
      },
      introspection: {
        enabled: true
      },
      revocation: {
        enabled: true
      },
      registration: {
        enabled: true,
        initialAccessToken: false
      }
    },
    // Supported grant types
    grants: ['authorization_code', 'client_credentials', 'refresh_token'],
    // Supported response types
    responseTypes: ['code'],
    // Token lifetimes
    ttl: {
      AccessToken: 3600, // 1 hour
      AuthorizationCode: 300, // 5 minutes
      RefreshToken: 86400, // 24 hours
      ClientCredentials: 3600 // 1 hour
    },
    
    // Scopes
    scopes: ['mcp', 'read', 'write'],
    // Claims (minimal for OAuth2-only)
    claims: {
      openid: []
    },
    // Client authentication methods
    clientAuthMethods: [
      'client_secret_basic',
      'client_secret_post',
      'none' // For public clients
    ],
    // PKCE configuration
    pkce: {
      methods: ['S256'],
      required: function(ctx, client) {
        // Require PKCE for public clients
        return client.clientAuthMethod === 'none';
      }
    },
    // Custom adapter for file-based storage
    adapter: function(name) {
      return new FileAdapter(name);
    },
    // Custom client lookup for our file-based storage
    findAccount: function(ctx, sub) {
      return {
        // Simple account for OAuth2 (not used in client_credentials flow)
        accountId: sub,
        claims: function() {
          return {};
        }
      };
    },
    // Interaction handling (simplified for OAuth2)
    interactions: {
      url: function(ctx, interaction) {
        // For authorization_code flow, auto-approve for MCP clients
        return `/oauth/interaction/${interaction.uid}`;
      }
    },
    // Custom routes
    routes: {
      authorization: '/authorize',
      token: '/token',
      introspection: '/introspect',
      revocation: '/revoke',
      registration: '/register'
    },
    // Error handling
    renderError: function(ctx, out, error) {
      logger.oauth('OIDC Provider Error', {
        error: error.error,
        description: error.error_description,
        status: error.status
      });
      ctx.type = 'application/json';
      return ctx.body = {
        error: error.error,
        error_description: error.error_description
      };
    }
  };

  // Create and configure the provider
  createProvider = function(issuer) {
    var provider;
    provider = new Provider(issuer, configuration);
    
    // Event listeners for logging
    provider.on('grant.success', function(ctx) {
      var ref;
      return logger.oauth('Grant successful', {
        grant_type: ctx.oidc.params.grant_type,
        client_id: (ref = ctx.oidc.client) != null ? ref.clientId : void 0,
        scope: ctx.oidc.params.scope
      });
    });
    provider.on('grant.error', function(ctx, error) {
      var ref;
      return logger.oauth('Grant error', {
        error: error.message,
        grant_type: ctx.oidc.params.grant_type,
        client_id: (ref = ctx.oidc.client) != null ? ref.clientId : void 0
      });
    });
    provider.on('registration.success', function(ctx, client) {
      return logger.oauth('Client registration successful', {
        client_id: client.clientId,
        client_name: client.clientName,
        grant_types: client.grantTypes
      });
    });
    provider.on('registration.error', function(ctx, error) {
      var ref;
      return logger.oauth('Client registration error', {
        error: error.message,
        client_name: (ref = ctx.request.body) != null ? ref.client_name : void 0
      });
    });
    // Handle authorization endpoint for auto-approval
    provider.use(async function(ctx, next) {
      var details, error, ref, result;
      if (ctx.path === '/oauth/authorize' && ctx.method === 'GET') {
        try {
          // Get the interaction
          // Auto-approve authorization requests for MCP clients
          details = (await provider.interactionDetails(ctx.req, ctx.res));
          
          // Auto-grant for MCP scope
          if ((ref = details.params.scope) != null ? ref.includes('mcp') : void 0) {
            result = {
              consent: {
                grantId: details.grantId
              }
            };
            await provider.interactionFinished(ctx.req, ctx.res, result, {
              mergeWithLastSubmission: false
            });
            return;
          }
        } catch (error1) {
          error = error1;
          logger.oauth('Auto-approval error', {
            error: error.message
          });
        }
      }
      return (await next());
    });
    return provider;
  };

  module.exports = {createProvider, FileAdapter};

}).call(this);
